import { DataObject } from './internal';
declare class StError extends Error {
    /**
     * Creates an error using the given message.
     *
     * @param {string} message Message of the error
     */
    constructor(message: string);
}
export declare type Tokens = {
    name: string;
    expression: string;
};
export declare const ST_ERRORS: {
    format: StError;
    fillout: StError;
    data: StError;
};
/**
 * Provides methods that help with evaluation but do not fit into ST itself.
 */
export declare class Helper {
    /**
     * Checks whether the given string is a function ( {{ #name expression? }} ).
     *
     * @param {string} str String to check
     */
    static isFunction(str: string): boolean;
    /**
     * Checks whether the given string is a template ( {{ expression }} ).
     *
     * @param {string} str String to check
     */
    static isTemplate(str: string): boolean;
    /**
     * Checks whether the given object is an array.
     *
     * @param {object} item Object to check
     */
    static isArray(item: object | DataObject): boolean;
    /**
     * Takes any object, finds subtree based on given path and sets the object's
     * value to new_val. The object is returned.
     *
     * @param {DataObject} o
     * @param {string} path
     * @param {any} newVal
     */
    static resolve(o: DataObject, path: string, newVal: any): DataObject;
    /**
     * Accepts the given string and transforms it into function name and expression.
     * Output: { name: FUNCTION_NAME:STRING, expression: FUNCTION_EXPRESSION:STRING }
     *
     * @param {string} str String to tokenize.
     */
    static tokenize(str: string): Tokens;
    /**
     * Fills the given template using provided data.
     * 'raw' is true only for when this is called from #each
     * Because #each is expecting an array, it shouldn't be stringified.
     * Therefore we pass template:null, which will result in returning
     * the original result instead of trying to replace it into the template with
     * a stringified version
     *
     * @param {string} template Template used for fillout
     * @param {DataObject} data Data used for fillout
     * @param {boolean} raw Denotes whether we are working with array or string
     */
    static fillout(template: string, data: DataObject, raw: boolean, keepTemplate?: boolean): string;
    static _fillout(template: string, variable: string, data: DataObject, keepTemplate?: boolean): string;
}
export {};
